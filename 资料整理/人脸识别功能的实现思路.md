# Camera
## 前言
android相机使用可分两种情况：
- android直接调用相机拍照，通过Intent指定Action和Category，再通过startActivityForResult（）获取到拍照的回调。
此方式获取的是系统相机，需先拍摄照片再进行后续处理。
适用场合：简单拍照。

- 对相机预览的图像进行处理，需要通过Android的相机Camera来进行操作。
获取相机预览的视频主要需要三个东西
Camera  相机必须使用
Surfaceview 相当于一个View，用来显示预览视频的控件，可以用TextureView代替
SurfaceHolder ，Holder在其中扮演了纽带的作用，控制着Camera和Surface之间的联系。
适用场合：视频直播、美颜相机等。

此处主要介绍如何使用opencv自带函数开启摄像头。

## Camera

### 简要说明
Camera是Android摄像头硬件的相机类，位于包"android.hardware.camera"下。它主要用于摄像头捕获图片、启动/停止预览图片、拍照、获取视频帧等，在Google 推出Android 5.0的时候, 被废弃。

### 源码地址
https://github.com/WuKaik/QuickCamera1

### 使用简要说明
1. 调用`Camera.getNumberOfCameras()`获取系统摄像头数量，获取指定摄像头Id

2. 通过`Camera.open(int cameraId)`返回一个camera,若调用`Camera.open()`,默认打开后置摄像头

3. 利用`camera.getParameters()`得到相机默认设置Camera.Parameters,如需修改，修改Camera.Parameters并调用`camera.setParameters(Camera.Parameters)`来修改设置

4. 调用`camera.setDisplayOrientation(int)`来设置正确的预览方向

5. 调用`camera.setPreviewDisplay(SurfaceHolder)`来设置预览

6. 调用`camera.startPreview()`来开启预览,预览数据在预览接口回调`camera.setPreviewCallback()`中获取

7. 调用`camera.takePicture()`拍照，拍照数据在拍照接口回调`Camera.PictureCallback()` 中获取

### 注意点
- 拍摄照片后，相机会停止预览，如需继续预览，需要再次调用`camera.startPreview()`重新开始预览
- 在Activity的`onPause()`方法，需要释放Camera资源；`onResume()`方法，重新获取Camera开启预览

### 自定义camera步骤及使用函数
1. 打开相机，即实例化Camera对象，Camera camera = Camera.open();

2. 设置Camera的相关参数，Camera.Parameters parameters = camera.getParameters();

3. 打开预览，camera.setPreviewDisplay(surfaceholder); camera.startPreview();

4. 获取图片，这里只是从预览中获取因此使用，camera.setPreviewCallback(new Camera.PreviewCallback(){……..});

5. 停止预览，释放相机。
`camera.stopPreview();camera.release();`

##SurfaceView
### 简要说明
在Android系统中，有一种特殊的视图，称为SurfaceView。它符合一切View的特性，需要通过Canvas画布绘制。
- SurfaceView拥有独立的Surface（绘图表面）
- SurfaceView是用Zorder排序的，他默认在宿主Window的后面，SurfaceView通过在Window上面“挖洞”（设置透明区域）进行显示

### SurfaceView与View的区别
1. View的绘图效率不高，主要用于动画变化较少的程序
2. SurfaceView 绘图效率较高，用于界面更新频繁的程序
3. SurfaceView拥有独立的Surface（绘图表面），即它不与其宿主窗口共享同一个Surface。
4. SurfaceView的UI可以在一个独立的线程中进行绘制，可以不会占用主线程资源。
6. SurfaceView使用双缓冲机制，播放视频时画面更流畅

### 使用场景
SurfaceView一方面可以实现复杂而高效的UI，另一方面又不会导致用户输入得不到及时响应。常用于画面内容更新频繁的场景，比如游戏、视频播放和相机预览。

### 使用步骤
- 获取SurfaceHolder对象，其是SurfaceView的内部类。添加回调监听Surface生命周期。
```java
mSurfaceHolder = getHolder();
mSurfaceHolder.addCallback(this);
```

- surfaceCreated 回调后启动绘制线程
只有当native层的Surface创建完毕之后，才可以调用lockCanvas()，否则失败。
```java
public void surfaceCreated(SurfaceHolder holder) {
        mDrawThread = new DrawThread();
        mDrawThread.start();
}
```

- 绘制
```cpp
Canvas canvas = mSurfaceHolder.lockCanvas();
      // 使用canvas绘制内容
      ...
mSurfaceHolder.unlockCanvasAndPost(canvas);
```

## Map
### 简要说明
Mat是OpenCV中用来存储图像信息的内存对象；
当通过Imgcodecs.imread()方法从文件读入一个图像文件时，imread方法就会返回Mat对象实例；或者通过Utils.bitmatToMat()方法由Bitmap对象转换得到Mat对象实例。

通过它可以获取图像的常见属性、像素数据，修改图像的像素数据，呈现出不同的图像显示效果，保存图像，等。

### 加载图片与读取基本信息
从Android系统中选择一张图像时，可以使用如下代码将图像文件加载为Mat对象：
`Mat src = Imgcodecs.imread(fileUri.getPath()); `

OpenCV通过imread来加载图像，默认加载的是三通道顺序为BGR的彩色图像；
还可以通过以下代码来指定加载为彩色图像：
`Mat src = Imgcodecs.imread(fileUri.getPath(), Imgcodecs.IMREAD_COLOR)`
如上这句代码，

第一个参数表示文件路径;第二个参数表示加载图像类型，最常见的类型有如下几种：
- IMREAD_UNCHANGED= -1，表示不改变加载图像类型，可能包含透明通道。
- IMREAD_GRAYSCALE= 0，表示加载图像为灰度图像。
- IMREAD_COLOR= 1，表示加载图像为彩色图像。


### Mat创建与初始化
Mat对象中包含了图像的各种基本信息与图像像素数据；Mat是由头部与数据部分组成的，其中头部还包含一个指向数据的指针。

在OpenCV4Android的接口封装中，因为Java层面没有指针对象，因此全部用数组来替代;但是，当我们需要把Mat对象传到JNI层的时候，可以通过getNativeObjAddr()方法来实现Mat对象从Java层到C++层的指针传递。

创建Mat对象的方法有很多种，如下几种最常见：
1. 通过create方法创建：
```java
Mat m1 = new Mat();
m1.create(new Size(3, 3), CvType.CV_8UC3);
```

1. 通过ones、eye、zeros方法初始化创建：
```java
Mat m4 = Mat.eye(new Size(3, 3),CvType.CV_8UC3);
Mat m5 = Mat.zeros(new Size(3, 3), CvType.CV_8UC3);
Mat m6 = Mat.ones(new Size(3, 3), CvType.CV_8UC3);
```

1. 先定义Mat，然后通过setTo方法实现初始化：
````java
Mat m7 = new Mat(3, 3, CvType.CV_8UC3);
m7.setTo(new Scalar(255, 255, 255));
````

1. 通过Mat的copyTo()与clone()实现对象的创建：
```java
at m8 = new Mat(500, 500, CvType.CV_8UC3);
m8.setTo(new Scalar(127, 127, 127));
Mat result = new Mat();
m8.copyTo(result)
```

### Mat对象保存
创建好的Mat对象经过一系列的操作之后，就可以通过OpenCV4Android的imwrite函数直接将对象保存为图像：
```java
// 创建Mat对象并保存
Mat image = new Mat(500, 500, CvType.CV_8UC3);
image.setTo(new Scalar(127, 127, 127));
ImageSelectUtils.saveImage(image);
```
saveImage方法内容如下：
```java
File fileDir = new File(Environment.getExternalStoragePublicDirectory(
Environment.DIRECTORY_PICTURES), "mybook");
if(！fileDir.exists()) {
　　fileDir.mkdirs();
}
String name = String.valueOf(System.currentTimeMillis()) + "_book.jpg";
File tempFile = new File(fileDir.getAbsoluteFile()+File.separator, name);
Imgcodecs.imwrite(tempFile.getAbsolutePath(), image);
```


## Opencv调用摄像头
android从5.0之后 camera 有两套API分别是 CameraAPI 1 和 CameraAPI 2。在OpenCV中已经为我们封装了两个类 JavaCameraView 和 JavaCamera2View， 顾名思义，JavaCameraView 封装的就是我们的 Camera 1，另外一个就是2。

### opencv使用摄像头准备
使用opencv去访问android设备摄像头， C++库是无法获取到android设备硬件的，所有需要借助Opencv对android提供的java库进行访问android设备摄像头。在opencv官方下载AndroidSDK，导入项目中就可以使用了。

### JavaCameraView类
JavaCameraView继承自CameraBridgeViewBase，CameraBridgeViewBase又继承自SurfaceView。

JavaCameraView可以显示摄像头捕获到的帧数据的View，CameraBridgeViewBase类中CvCameraViewListener2接口提供了摄像头onCameraViewStarted、onCameraViewStopped以及onCameraFrame回调。

我们要对摄像头捕获的每一帧数据进行操作就需要再OnCameraFrame回调中进行处理。通过一个native函数，在将摄像头的每一帧数据地址传给C++，对帧数据进行操作。

JavaCameraView类的集成关系：

![](https://img-blog.csdnimg.cn/20190429134230782.png)
可以看到 OpenCV 给我们提供的 JavaCameraView 和 JavaCamera2View 最终都是继承 SurfaceView 的CameraBridgeViewBase 就相当于一个桥梁，关系到最终的作用。

### 开启接口
我们根据流程从 setCvCameraViewListener() 接口开启：
首先通过这个接口会创建一个 CvCameraViewListenerAdapter 对象，代码如下：
```java
  public void setCvCameraViewListener(CvCameraViewListener listener) {
        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);
        adapter.setFrameFormat(mPreviewFormat);
        mListener = adapter;
    }

```
然后 CvCameraViewListenerAdapter 的代码：
```java
    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {
        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {
            mOldStyleListener = oldStypeListener;
        }
        public void onCameraViewStarted(int width, int height) {
            mOldStyleListener.onCameraViewStarted(width, height);
        }
        public void onCameraViewStopped() {
            mOldStyleListener.onCameraViewStopped();
        }
        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {
             Mat result = null;
             switch (mPreviewFormat) {
                case RGBA:
                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());
                    break;
                case GRAY:
                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());
                    break;
                default:
                    Log.e(TAG, "Invalid frame format! Only RGBA and Gray Scale are supported!");
            };
 
            return result;
        }
        public void setFrameFormat(int format) {
            mPreviewFormat = format;
        }
        private int mPreviewFormat = RGBA;
        private CvCameraViewListener mOldStyleListener;
    };

```



